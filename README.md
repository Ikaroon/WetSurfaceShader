# WetSurfaceShader
 A shader that visualizes water drops on surfaces using HDRP, Shader Graph, and VFX Graph

## Implementation

### VFX Graph
There are three VFX graphs that can be used:
- Flow VFX graph that simulates droplets of water running down a surface
- Drips VFX graph that simulates ripples of water when drips hit a puddle
- Dots VFX graph that simulates drops of water splashing on a dry surface

The Flow VFX graph doesn't use strips or trails but instead texture smearing to imitate trails of water. This is done to make advantage of the "Tile/Warp" block in VFX graph in order to make the texture almost seamless.
Ensuring to have a seamless texture allows us to save a sample when blending between the texture chunks.

The drops in the VFX graph jiggle from left to right, slow down occasionally and change brightness randomly to simulate droplet residues when running down a surface.

The Drips and Dots VFX graphs spawn particles within an area and fade them out over time.

### Shader
There is one shader implemented in Shader Graph that implements various features.

#### Mappings
1. UV Top:
	Maps the top texture (either drips or dots) using the geometry's UV data.
2. UV Side:
	Maps the side texture (flow texture) using the geometry's UV data.
3. Triplanar:
	Maps the top and side textures using the world position and normal combined with a blending factor.
4. World XZ Top:
	Maps the top texture using the world position.
	
#### Top Texture Type
1. Drips:
	Uses the texture generated by the Drips VFX graph that simulates ripples
2. Dots:
	Uses the texture generated by the Dots VFX graph that simulates drops of water on a dry surface.
	
#### Refract Scene
This is an optional effect that refracts the image using the "scene color" or "grab pass" implementation.
This effect isn't strong and can be toggled off for opaque surface or when performance should be improved further.

#### Fluid
Next to colouring the fluid it is possible to set its smoothness and the overall wetness.
The normal strength defines how strongly the normal map gets generated from the heightmap.

#### Surface
The custom Shader GUI allows you to change between the shader's opaque and transparent variant.
Next to that you can choose a diffuse and normal map including their tilings.
You can also tint the surface and add a base smoothness.

## Usage
When using the shader it is advisable to choose the mapping that fits the mesh best.
However, while triplanar mapping works in most situations it is also the solution that requires the most texture samples.
If the geometry has UVs that generally follow gravity along the y axis it is possible to choose the desired uv mapping.

## Optimisation

### Sample Count
The most versatile implementation of this effect is the triplanar variant.
However, as said in the section before, it is the variant with the highest sample count.
To reduce this sample count it isn't strictly required to fall back to UV mapping. This depends on the further situation of the games effects and shaders.

Some solutions to this problem are:
1. Biplanar mapping
While this approach only removes one of the three samples it potentially improves performance slightly if samples are a problem for the targetted platform. It favours math over samples.
However, because it only samples two textures it isn't purely compatible with the top/side texture approach implemented in the shader except when using if conditions in the fragmet stage of the shader which generally not advisable. Proper testing of performance on the target platform should be done here before choosing this approach.
2. Dithered Mapping
Dithered mapping might sound cheap but it allows to reduce the effective sampling count to one. While it still needs to either sample a texture or read a dither matrix this can be shared among many shaders that use similar effects.
This mapping is especially useful when using temporal anti-aliasing as it allows for using blue noise textures. Their hardly recognisable repetition combined with the frame blending of TAA hides the dithering adequately.

### VFX Graph Simulation
It is a balance between memory and runtime calulations. At the moment the VFX graphs run in the background and are rendered using secondary cameras. It is possible to bake the VFX graphs in textures and interpolate them in the shader, however, this increases texture data compared to the current implementation.
Especially the Dots VFX Graph can be baked into a texture as it hardly animates anything but rather only shows drops at varying times.

With more time I would properly spend time in investigating proven baking approaches for this kind of animated textures. At the moment I am weary to feature interpolation over texture rendering.

### Automatic UV Baking
Next to triplanar mapping we can map the texture using the UV data. However, depending on its layout it may lead to water running up- or sidewards. To fix this you either have to manually author the UV channels or to create an automatic UV baking.
Such an implementation could struggle with curved geometry though and would need proper testing with a broad spectrum of geometry first.